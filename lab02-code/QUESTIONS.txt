			   __________________

			    LAB 02 QUESTIONS
			   __________________


- Name: Dale Marttinen
- NetID: mart2439

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete the
lab.


PROBLEM 1: last_elem recursive function
=======================================

(A)
~~~

  Start the OCaml REPL in the `lab02-code' directory and load the
  `rec_funcs.ml' source file with a `#use' directive as shown.

  ,----
  | > ocaml
  | 	OCaml version 4.06.0
  | 
  | # #use "rec_funcs.ml";;
  | val last_elem : 'a list -> 'a = <fun>
  | val elems_outside : int -> int -> 'a list -> 'a list = <fun>
  | #
  `----

  The first function loaded from the source file is called `last_elem'.

  Describe in words the type of `last_elem' :
  - What kind of argument does it take?
  - What type does it return?
  - What does the 'a notation mean?

  last_elem takes in  a list of type 'a which means it can be a list of any type.
  Then it returns a a single item of type 'a which is whatever type the input list is.
  'a means it can be any type

(B)
~~~

  Call `last_elem' on several input lists in the REPL and show the
  return values.
  - Make sure to call the function on an empty list and report what
    happens.
  - Make sure to use several different types of lists (int list, string
    list) and a few different lengths.

  Paste your REPL transcript below AND describe in a line or two what
  the function does.
# last_elem [1;2;3;4;5];;
- : int = 5
# last_elem ["l";"i";"s";"t"];;
- : string = "t"
#

last_elem returns the last element in a list regardless of the type of list given.


(C)
~~~

  Examine the definition of `last_elem' in `rec_funcs.ml'. Study how it
  operates carefully to gain insight on recursive functions.

  Add comments in your own words that describe line-by-line how the
  function operates. Paste your commented version of the code below.
  
let rec last_elem list = (*recursive function that takes in a list of any type*)
  if list = [] then (*check if the input list is empty. If it is then throw a message*)
    raise (Failure "No last element in an empty list")
  else
    let elem = List.hd list in (*grab the first element in the list*)
    let rest = List.tl list in (*grab the rest of the list*)
    if rest = [] then (*check if the rest of the list is empty, which means there's only one element in the list*)
      elem (*if there's only one element, this must be the last so return it*)
    else
      last_elem rest (*if there are other elements in the list, call last_elem on whatever is left*)
;;
  
  
  

PROBLEM 2: elems_outside with recursive helper function
=======================================================

(A)
~~~

  The other function loaded by `rec_funcs.ml' is called `elems_outside'.
  As before, describe it's type.
  - How many parameters does it take and what type are they?
  - What type does it return?
elems_outside takes in three parameters. Two ints, and a list of any type.
It returns a list of the same type given.

(B)
~~~

  In the REPL, call `elems_outside' on several lengths and types of
  lists. Show the results generated by these calls by pasting your REPL
  session below. Describe what the function appears to be doing.
# elems_outside 0 3 [1;2;4;5;6;7;8;9;0;123;23414;23];;
- : int list = [6; 7; 8; 9; 0; 123; 23414; 23]
# elems_outside 1 2 ["r";"t";"y";"u"];;
- : string list = ["r"; "u"]

elems_outside returns a string with whatever values are before the first int,
and whatever are after the second int.


(C)
~~~

  Examine the definition of `elems_outside' in `rec_funcs.ml'. Study how
  it operates carefully to gain insight on recursive functions.

  Add comments in your own words that describe line-by-line how the
  function operates. Paste your commented version of the code below.
  
let elems_outside start stop list = (*function that takes in 2 ints and a list of type 'a*)
  let rec helper pos lst = (*beginning of recursive functino that takes in an int and a list of type 'a. The int is going to be a position in the list, and the list is the given list from elems_outside*)
    if lst=[] then (*check if the list is empty, if so, then return the empty list*)
      []
    else if start<=pos && pos<=stop then (*check if the current position is between the two input values from elems_outside*)
      helper (pos+1) (List.tl lst) (*if it is, call the helper function again, this time with the position value incremented by 1*)
    else(*if the position value is outisde of the given ints then*)
      let elem = List.hd lst in (*grab the first element in the list*)
      let rest = List.tl lst in (*grab the rest of the list*)
      let result =  helper (pos+1) rest in (*call the helper function with the rest of the list, and the position value incremented by 1*)
      elem :: result (*and build a new list with the head of the input list and whatever the helper function returns*)
  in
  helper 0 list (*call the helper function with a starting position of 0, and the entire input list*)
;;

Problem 3
=========

(A)
~~~

  Examine the two functions provided in `sorting.ml': `sorted_insert'
  and `sort'. Describe the parameter and return types for both
  functions. Based on the comments and source code, determine their
  purpose.
sorted_insert:
takes an element of any type, and a list of the same type.
returns nothing.

sorted_insert takes the given element and puts it into the list while maintaining the sorted order.
It then ends without returning anything since all that happened was the list got updated.

sort:
takes in a list of any type.
returns nothing.

sort takes in a list and sorts it by grabbing the first element out of the list, and inserting it into a sorted list by recursively calling sorted_insert


(B)
~~~

  The code provided for this problem is an adaptation of code from the
  Ocaml System Manual Section 1.2 which is here
  [http://caml.inria.fr/pub/docs/manual-ocaml/coreexamples.html#sec9]

  The original version looks like this:
  ,----
  | let rec sort lst =
  |   match lst with
  |     [] -> []
  |   | head :: tail -> insert head (sort tail)
  | and insert elt lst =
  |   match lst with
  |     [] -> [elt]
  |   | head :: tail -> if elt <= head then elt :: lst else head :: insert elt tail
  | ;;
  `----

  The version in `sorting.ml' has been re-written so that it is somewhat
  more verbose but potentially easier for a novice to understand.
  - Ordering of the functions is reversed so that insertion is defined
    prior to sorting
  - Two separate "let" bindings are used rather than a joint "let/and"
    binding
  - Pattern matching via "match" is replaced with "if/else" statements
  - Destructure binding is replaced with explicit calls to List.hd and
    List.tl

  All of the above concepts will eventually be covered and it does not
  hurt one to look ahead a bit.

  COMPARE the code in `sorting.ml' to the original OSM version above.
  Make some observations about how the syntax associated with the
  "match" statement must work.
  
  the initial match command takes in the item to be matched, and then the with creates a series of cases to be matched against
  the case is defined, and then an -> is used to tell the function what to do if that case is matched.
  then a | is used to define another case to be matched against.